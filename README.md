cat > README.md << 'EOF'
## Отчёт по лабораторной работе: RISC‑V

### 1. Постановка задачи

Необходимо реализовать алгоритм на архитектуре RISC‑V для вычисления суммы элементов главной диагонали квадратной матрицы \(4 \times 4\) целых чисел.
Исходная матрица задаётся как:

\[
\begin{bmatrix}
1 & 2 & 3 & 4 \\
5 & 6 & 7 & 8 \\
9 & 10 & 11 & 12 \\
13 & 14 & 15 & 16
\end{bmatrix}
\]

Главная диагональ содержит элементы: 1, 6, 11, 16.
Ожидаемая сумма: \(1 + 6 + 11 + 16 = 34\).

Требования лабораторной:

- Реализовать алгоритм на языке C.
- Скомпилировать C‑код с помощью RISC‑V‑совместимого компилятора с флагами `-march=rv32i -mabi=ilp32`.
- Получить dump‑файл из скомпилированного исполняемого файла.
- Реализовать тот же алгоритм на языке ассемблера RISC‑V.
- Отладить и запустить ассемблерную программу в симуляторе Venus (расширение для VS Code), убедиться, что результат равен 34, и оформить отчёт.

---

### 2. Используемое окружение

- ОС: Ubuntu в WSL (Windows Subsystem for Linux) под Windows.
- IDE/редактор: Visual Studio Code.
- Симулятор RISC‑V: Venus (расширение для VS Code).
- Компилятор C → RISC‑V: заранее собранный тулчейн

riscv-gcc-10.2.0-gbbc9263-210318T1412


установленный в каталог:

/home/qusae/riscv-tools/riscv-gcc-10.2.0-gbbc9263-210318T1412

- Путь к каталогу `bin` тулчейна добавлен в переменную окружения `PATH`:

export PATH=$HOME/riscv-tools/riscv-gcc-10.2.0-gbbc9263-210318T1412/bin:$PATH

---

### 3. Реализация на языке C

#### 3.1 Файл `algo.c`

#define N 4
#define M 4

int sum_diagonal(int arr[N][M]) {
int sum = 0;
for (int i = 0; i < N; i++) {
sum += arr[i][i]; // сумма элементов главной диагонали
}
return sum;
}

int main(void) {
int arr[N][M] = {
{ 1, 2, 3, 4 },
{ 5, 6, 7, 8 },
{ 9, 10, 11, 12 },
{ 13, 14, 15, 16 }
};
int result = sum_diagonal(arr);
return result;  // код возврата программы равен 34
}

Комментарии:

N и M задают размер матрицы 
4×4.
Функция sum_diagonal выполняет цикл по индексу i от 0 до 3 и суммирует элементы arr[i][i].
Функция main инициализирует матрицу, вызывает функцию и возвращает сумму как код завершения процесса (для кросс‑компиляции достаточно, печать через printf не используется).

#### 3.2 Компиляция C‑кода под RISC‑V

riscv64-unknown-elf-gcc -march=rv32i -mabi=ilp32 algo.c -o algo.elf

-march=rv32i — целевая архитектура (базовый набор инструкций RISC‑V 32‑бит).
-mabi=ilp32 — ABI: типы int, long и указатели имеют размер 32 бита.
-В результате получается исполняемый ELF‑файл algo.elf для архитектуры RISC‑V.


#### 3.3 Получение dump‑файла

Согласно методическим указаниям, для получения дампа используется objdump:

riscv64-unknown-elf-objdump -D algo.elf > algo.dump


Файл `algo.dump` добавляется в репозиторий.

---

### 4. Программа на ассемблере RISC‑V

#### 4.1 Общее описание

Ассемблерная программа реализует ту же задачу: сумма элементов главной диагонали матрицы \(4 \times 4\).
Матрица хранится в `.data` как 16 слов (`.word`), цикл в `.text` последовательно обрабатывает элементы `[i][i]`.
Итоговая сумма сохраняется в регистре `t2`.

#### 4.2 Код `algo.s`

.data
array: .word 1, 2, 3, 4
.word 5, 6, 7, 8
.word 9,10,11,12
.word 13,14,15,16

.text
.globl main
main:
la t0, array # t0 = базовый адрес массива
li t1, 0 # t1 = i (индекс по диагонали)
li t2, 0 # t2 = sum (накопленная сумма)

loop:
li t3, 4 # N = 4
bge t1, t3, end # если i >= 4, перейти к end
li a0, 4
mul a1, t1, a0    # a1 = i * 4
add a1, a1, t1    # a1 = i*4 + i (линейный индекс элемента [i][i])
slli a1, a1, 2    # умножаем на 4, получаем смещение в байтах
add a2, t0, a1    # a2 = адрес элемента array[i][i]
lw  a3, 0(a2)     # a3 = array[i][i]
add t2, t2, a3    # sum += array[i][i]

addi t1, t1, 1    # i++
j loop            # переход к следующей итерации
end:
nop # в этот момент t2 = 34

---
Пояснение ключевых шагов:

la t0, array — загрузка адреса начала массива в t0.

li t1, 0, li t2, 0 — инициализация счётчика и суммы.

Вычисление линейного индекса диагонального элемента: i * 4 + i.

Умножение на 4 (через slli) для получения байтового смещения, так как элементы хранятся как 32‑битные слова.

Загрузка значения слова lw и добавление к сумме.

### 5. Отладка в симуляторе Venus (VS Code)

1. Открыт каталог `lab-riscv-asm` в VS Code, файл `algo.s` открыт в редакторе.
2. В правом нижнем углу выбран язык **RISC‑V Assembly**, чтобы активировать расширение Venus.

> Место для изображения №1: скриншот VS Code с открытым `algo.s` и выбранным языком RISC‑V Assembly.

3. Через Command Palette (`Ctrl+Shift+P`) запущен симулятор Venus (Run/Debug).
4. Программа выполняется до метки `end:`.

> Место для изображения №2: скриншот окна Venus во время выполнения программы.

5. На вкладке регистров видно, что после завершения цикла регистр `x07 (t2)` содержит значение `0x00000022` (34 в десятичной системе).

> Место для изображения №3: скриншот панели регистров, где `t2 = 0x00000022`.

---

### 6. Структура репозитория

Итоговое содержимое каталога `lab-riscv-asm`:

- `algo.c` — реализация алгоритма на C.
- `algo.s` — реализация алгоритма на ассемблере RISC‑V.
- `algo.elf` — исполняемый файл для RISC‑V.
- `algo.dump` — дамп дизассемблированного кода.
- `README.md` — данный отчёт.
- (опционально) файлы скриншотов, используемые в отчёте.

---

### 7. Замечания по настройке тулчейна

1. Попытка использовать `riscv64-linux-gnu-gcc` из репозиториев Ubuntu привела к ошибкам вида:

   - `fatal error: gnu/stubs-ilp32.h: No such file or directory`
   - `/usr/.../libgcc_s.so.1: error adding symbols: file in wrong format`

   что указывает на отсутствие/конфликт библиотек `glibc` и `libgcc_s` под RISC‑V `ilp32`.

2. Ссылка на заранее собранный RISC‑V‑тулчейн из методички поначалу не открывалась, поэтому установить рекомендуемый компилятор напрямую не удалось.

3. Позже архив `riscv-gcc-10.2.0-gbbc9263-210318T1412` был получен от одногруппника, распакован в каталог:

~/riscv-tools/riscv-gcc-10.2.0-gbbc9263-210318T1412


и путь к `bin` добавлен в `PATH`:

export PATH=$HOME/riscv-tools/riscv-gcc-10.2.0-gbbc9263-210318T1412/bin:$PATH


После этого компилятор `riscv64-unknown-elf-gcc` и утилита `riscv64-unknown-elf-objdump` заработали корректно, что позволило собрать `algo.c` с нужными флагами и получить `algo.dump` в соответствии с требованиями задания.
EOF
